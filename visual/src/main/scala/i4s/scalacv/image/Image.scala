package i4s.scalacv.image

import com.google.common.hash.{HashCode, Hashing}
import i4s.scalacv.core.constants.AccessFlags
import i4s.scalacv.core.constants.AccessFlags.AccessFlag
import i4s.scalacv.core.model.mats._
import i4s.scalacv.core.model.mats.syntax._
import i4s.scalacv.core.model.{Scalar, Size}
import i4s.scalacv.core.types.{MatTypes, Types}
import i4s.scalacv.core.types.Types.{Cv8U, Type}
import org.bytedeco.javacv.{Java2DFrameConverter, OpenCVFrameConverter}

import java.awt.image.BufferedImage
import scala.util.Using

object Image {

  def apply(rows: Int, cols: Int, channels: Int, init: Scalar): Image =
    new Image(new org.bytedeco.opencv.opencv_core.Mat(Array(rows,cols),MatTypes.makeType(Cv8U,channels),init))

  def apply(rows: Int, cols: Int, channels: Int): Image =
    new Image(new org.bytedeco.opencv.opencv_core.Mat(Array(rows,cols),MatTypes.makeType(Cv8U,channels)))

  def apply(rows: Int, cols: Int, init: Scalar): Image =
    new Image(new org.bytedeco.opencv.opencv_core.Mat(Array(rows,cols),MatTypes.makeType(Cv8U,3),init))

  def apply(rows: Int, cols: Int): Image =
    new Image(new org.bytedeco.opencv.opencv_core.Mat(Array(rows,cols),MatTypes.makeType(Cv8U,3)))

  def apply(size: Size, channels: Int, init: Scalar): Image =
    new Image(new org.bytedeco.opencv.opencv_core.Mat(size,MatTypes.makeType(Cv8U,channels),init))

  def apply(size: Size, channels: Int): Image =
    new Image(new org.bytedeco.opencv.opencv_core.Mat(size,MatTypes.makeType(Cv8U,channels)))

  def apply(size: Size, init: Scalar): Image =
    new Image(new org.bytedeco.opencv.opencv_core.Mat(size,MatTypes.makeType(Cv8U,3),init))

  def apply(size: Size): Image =
    new Image(new org.bytedeco.opencv.opencv_core.Mat(size,MatTypes.makeType(Cv8U,3)))

  def apply(wrapped: org.bytedeco.opencv.opencv_core.UMat, accessFlag: AccessFlag): Image =
    new Image(wrapped.getMat(accessFlag.id).clone)

  def apply(wrapped: org.bytedeco.opencv.opencv_core.Mat): Image =
    new Image(wrapped.clone)

  def apply(image: Image): Image =
    new Image(image.clone())

  import scala.language.implicitConversions
  implicit def mat2Image(mat: org.bytedeco.opencv.opencv_core.Mat): Image = Image(mat)
  implicit def umat2Image(mat: org.bytedeco.opencv.opencv_core.UMat): Image = Image(mat,AccessFlags.ReadWrite)
}


/**
 * Wraps a [[org.bytedeco.opencv.opencv_core.Mat]] with a scala class wrapper to provide more idiomatic access to
 * image utilities and tools. The class constructor *takes over* management of the wrapped [[Mat]]. Care must be taken
 * to avoid wrapping a single [[Mat]] more than ones.
 *
 * It is expected that the companion object factory is used to create a fully specified [[Image]] object in most cases.
 * The wrapping constructor is used to efficiently project [[Image]] capabilities over a Mat that is generated by javacv.
 * In most cases, the companion object factor should be used.
 *
 * @param wrapped
 */
class Image(wrapped: org.bytedeco.opencv.opencv_core.Mat) extends MappedMat[Scalar,Int](wrapped) {
  assert(Types(depth) == Cv8U, s"Unexpected type - ${Types(depth)}, Only Mats with depth = ${Types.Cv8U} are allowed")

  def getUMat(flag: AccessFlag): org.bytedeco.opencv.opencv_core.UMat = super.getUMat(flag.id)

  def toBufferedImage: BufferedImage = {
    Using.resource(new OpenCVFrameConverter.ToMat()) { openCVConverter =>
      Using.resource(openCVConverter.convert(this)) { frame =>
        Using.resource(new Java2DFrameConverter()) { java2DConverter =>
          java2DConverter.convert(frame)
        }
      }
    }
  }

  def dataType: Type = Types(super.depth)

  def description: String = {
    val sizeString = s"${size().width} x ${size().height()}"
    s"Image(Mat) (${dims()}) = [${sizeString}] - type: ${matType} (${`type`()}), channels = $channels, dataType = $dataType, total = $total "
  }

}
